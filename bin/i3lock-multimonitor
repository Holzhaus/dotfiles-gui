#!/bin/bash
CACHE_DIR="${HOME}/.cache/i3lock"
BACKGROUND_IMAGE="$1"
OVERLAY_IMAGE="$2"


if ! [ -e "${BACKGROUND_IMAGE}" ]; then
    printf 'Error: Image "%s" not found, continuing without image...\n' "${BACKGROUND_IMAGE}" >&2
    IMAGE_ARGS=()
else
    notify-send -u low "Locking Screen..." "Please wait while the screenlock is prepared."

    if ! [ -d "${CACHE_DIR}" ]; then
        mkdir -p "${CACHE_DIR}"
    fi

    # If BACKGROUND_IMAGE is a directory, select a random JPG/PNG file from it
    if [ -d "${BACKGROUND_IMAGE}" ]; then
        BACKGROUND_IMAGE="$(find "${BACKGROUND_IMAGE}" -maxdepth 1 -type f \( -iname "*.jpg" -or -iname "*.png" \) | shuf -n 1)"
    fi

    # Get the current XRANDR configuration
    XRANDR="$(xrandr -q)"
    if [ -e "$OVERLAY_IMAGE" ]; then
        CHECKSUM="$(cat "${BACKGROUND_IMAGE}" "${OVERLAY_IMAGE}" <(printf '%s' "${XRANDR}") | md5sum -)"
    else
        CHECKSUM="$(cat "${BACKGROUND_IMAGE}" <(printf '%s' "${XRANDR}") | md5sum -)"
    fi
    IMAGE_PATH="${CACHE_DIR}/${CHECKSUM%  *}.png"

    # We do not have a cached lockscreen image for this configuration, create a new one
    if ! [ -e "${IMAGE_PATH}" ]; then
        printf '%s does not exist, creating...\n' "${IMAGE_PATH}" >&2
        IMAGE_WIDTH=0
        IMAGE_HEIGHT=0
        IM_ARGS=""
        TEMP_DIR="$(mktemp -t -d "i3lock.XXXXXXXXXX")"
        trap 'rm -rf "${TEMP_DIR}"' EXIT

        if [ -e "${OVERLAY_IMAGE}" ]; then
            BASE_IMAGE="${TEMP_DIR}/base.png"
            convert "${BACKGROUND_IMAGE}" "${OVERLAY_IMAGE}" -gravity center  -composite "${BASE_IMAGE}"
        else
            BASE_IMAGE="${BACKGROUND_IMAGE}"
        fi

        while read -r LINE
        do
            if [[ "$LINE" =~ ([0-9]+)x([0-9]+)\+([0-9]+)\+([0-9]+) ]]; then
                SCREEN_WIDTH=${BASH_REMATCH[1]}
                SCREEN_HEIGHT=${BASH_REMATCH[2]}
                SCREEN_X=${BASH_REMATCH[3]}
                SCREEN_Y=${BASH_REMATCH[4]}
                printf 'Found active screen: %s\n' "${BASH_REMATCH[0]}" >&2

                TEMP_IMG="${TEMP_DIR}/${SCREEN_WIDTH}x${SCREEN_HEIGHT}.png"
                if ! [ -e "${TEMP_IMG}" ]
                then
                    convert "${BASE_IMAGE}" -resize "${SCREEN_WIDTH}X${SCREEN_HEIGHT}^" -gravity center -crop "${SCREEN_WIDTH}X${SCREEN_HEIGHT}+0+0" +repage "${TEMP_IMG}" || {
                        SCREEN_WIDTH=0
                        SCREEN_HEIGHT=0
                        break
                    }
                fi

                (( IMAGE_WIDTH < (SCREEN_WIDTH+SCREEN_X) )) && IMAGE_WIDTH=$(( SCREEN_WIDTH + SCREEN_X ))
                (( IMAGE_HEIGHT < (SCREEN_HEIGHT+SCREEN_Y) )) && IMAGE_HEIGHT=$(( SCREEN_HEIGHT + SCREEN_Y ))

                IM_ARGS="${IM_ARGS} ${TEMP_IMG} -geometry +${SCREEN_X}+${SCREEN_Y} -composite"
            fi
        done <<< "$(printf '%s' "${XRANDR}")"

        if (( IMAGE_WIDTH > 0 )) && (( IMAGE_WIDTH > 0 )); then
            TEMP_IMG="${TEMP_DIR}/${IMAGE_WIDTH}x${IMAGE_HEIGHT}-final.png"
            convert -size "${IMAGE_WIDTH}x${IMAGE_HEIGHT}" "xc:black" "${TEMP_IMG}"
            convert "${TEMP_IMG}" ${IM_ARGS} "${TEMP_IMG}"
            mv "${TEMP_IMG}" "${IMAGE_PATH}"
        fi
    fi

    if ! [ -e "${IMAGE_PATH}" ]; then
        printf 'Warning: Image processing failed, using original image.\n' >&2
        IMAGE_PATH="${BASE_IMAGE}"
    fi

    IMAGE_ARGS=(-i "${IMAGE_PATH}")
fi

# Finally lock the screen
printf 'Locking screen...\n' >&2
if [[ -e /dev/fd/${XSS_SLEEP_LOCK_FD:--1} ]]; then
    kill_i3lock() {
        pkill --exact --euid $EUID "$@" i3lock
    }
    trap kill_i3lock TERM INT
    # we have to make sure the locker does not inherit a copy of the lock fd
    i3lock "${IMAGE_ARGS[@]}" "$@" {XSS_SLEEP_LOCK_FD}<&-
    # now close our fd (only remaining copy) to indicate we're ready to sleep
    exec {XSS_SLEEP_LOCK_FD}<&-
    while kill_i3lock -0; do
        sleep 0.5
    done
else
    trap 'kill %%' TERM INT
    i3lock --nofork "${IMAGE_ARGS[@]}" "$@" &
    wait
fi
